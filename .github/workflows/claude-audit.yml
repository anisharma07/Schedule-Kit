name: Claude AI Code Audit

on:
  push:
    branches: [main, master, develop]
    paths:
      - "src/**"
      - "package.json"
      - "tsconfig.json"
      - "*.config.*"
  workflow_dispatch:
    inputs:
      audit_scope:
        description: "Audit scope (all, security, performance, maintainability, cleanup)"
        required: false
        default: "all"
        type: choice
        options:
          - all
          - security
          - performance
          - maintainability
          - cleanup
      include_suggestions:
        description: "Include improvement suggestions"
        required: false
        default: true
        type: boolean
  schedule:
    # Run every 6 hours (at 0:00, 6:00, 12:00, 18:00 UTC)
    - cron: "0 */6 * * *"

jobs:
  audit-codebase:
    runs-on: ubuntu-latest
    timeout-minutes: 120

    permissions:
      contents: write
      pull-requests: write
      issues: write
      actions: read

    env:
      AUDIT_SCOPE: ${{ github.event.inputs.audit_scope || 'all' }}
      INCLUDE_SUGGESTIONS: ${{ github.event.inputs.include_suggestions || 'true' }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Detect repository type and target branch
        id: repo-info
        run: |
          echo "üîç Detecting repository information..."

          # Get repository information
          REPO_FULL_NAME="${{ github.repository }}"
          CURRENT_REPO_OWNER="${{ github.repository_owner }}"
          CURRENT_REPO_NAME="${{ github.event.repository.name }}"
          CURRENT_BRANCH="${{ github.ref_name }}"
          DEFAULT_BRANCH="${{ github.event.repository.default_branch }}"

          echo "current_repo_owner=$CURRENT_REPO_OWNER" >> $GITHUB_OUTPUT
          echo "current_repo_name=$CURRENT_REPO_NAME" >> $GITHUB_OUTPUT
          echo "current_branch=$CURRENT_BRANCH" >> $GITHUB_OUTPUT
          echo "default_branch=$DEFAULT_BRANCH" >> $GITHUB_OUTPUT

          # Check if this is a fork
          IS_FORK="${{ github.event.repository.fork }}"
          echo "is_fork=$IS_FORK" >> $GITHUB_OUTPUT

          if [[ "$IS_FORK" == "true" ]]; then
            echo "üç¥ Repository is a fork. Attempting to get parent information..."
            
            # Try to get parent repository information via GitHub API
            PARENT_INFO=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/$CURRENT_REPO_OWNER/$CURRENT_REPO_NAME" | \
              jq -r '.parent // empty')
            
            if [[ -n "$PARENT_INFO" && "$PARENT_INFO" != "null" ]]; then
              PARENT_OWNER=$(echo "$PARENT_INFO" | jq -r '.owner.login // empty')
              PARENT_NAME=$(echo "$PARENT_INFO" | jq -r '.name // empty')
              PARENT_DEFAULT_BRANCH=$(echo "$PARENT_INFO" | jq -r '.default_branch // "main"')
              
              if [[ -n "$PARENT_OWNER" && "$PARENT_OWNER" != "null" ]]; then
                TARGET_REPO_OWNER="$PARENT_OWNER"
                TARGET_REPO_NAME="$PARENT_NAME"
                TARGET_BRANCH="$PARENT_DEFAULT_BRANCH"
                echo "‚úÖ Fork detected. Target: $PARENT_OWNER/$PARENT_NAME:$PARENT_DEFAULT_BRANCH"
              else
                echo "‚ö†Ô∏è Could not determine parent repository. Using current repo as target."
                TARGET_REPO_OWNER="$CURRENT_REPO_OWNER"
                TARGET_REPO_NAME="$CURRENT_REPO_NAME"
                TARGET_BRANCH="$DEFAULT_BRANCH"
              fi
            else
              echo "‚ö†Ô∏è Fork detected but parent info unavailable. Using current repo as target."
              TARGET_REPO_OWNER="$CURRENT_REPO_OWNER"
              TARGET_REPO_NAME="$CURRENT_REPO_NAME"
              TARGET_BRANCH="$DEFAULT_BRANCH"
            fi
          else
            # Original repository
            TARGET_REPO_OWNER="$CURRENT_REPO_OWNER"
            TARGET_REPO_NAME="$CURRENT_REPO_NAME"
            TARGET_BRANCH="$DEFAULT_BRANCH"
            echo "ÔøΩ Original repository. Target: $CURRENT_REPO_OWNER/$CURRENT_REPO_NAME:$DEFAULT_BRANCH"
          fi

          echo "target_repo_owner=$TARGET_REPO_OWNER" >> $GITHUB_OUTPUT
          echo "target_repo_name=$TARGET_REPO_NAME" >> $GITHUB_OUTPUT
          echo "target_branch=$TARGET_BRANCH" >> $GITHUB_OUTPUT

          # Generate unique branch name with timestamp
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          AUDIT_BRANCH="claude-audit-$TIMESTAMP"
          echo "audit_branch=$AUDIT_BRANCH" >> $GITHUB_OUTPUT

          echo "‚úÖ Repository analysis complete"
          echo "Current: $CURRENT_REPO_OWNER/$CURRENT_REPO_NAME"
          echo "Target: $TARGET_REPO_OWNER/$TARGET_REPO_NAME:$TARGET_BRANCH"
          echo "Audit branch: $AUDIT_BRANCH"

      - name: Clean up old audit branches
        continue-on-error: true
        run: |
          echo "üßπ Cleaning up old audit branches..."

          # Delete old audit branches (older than 7 days)
          git for-each-ref --format='%(refname:short) %(committerdate)' refs/remotes/origin/claude-audit-* | \
          while read branch date; do
            if [[ $(date -d "$date" +%s) -lt $(date -d "7 days ago" +%s) ]]; then
              branch_name=${branch#origin/}
              echo "üóëÔ∏è Deleting old branch: $branch_name"
              git push origin --delete "$branch_name" || echo "Failed to delete $branch_name"
            fi
          done

      - name: Configure AWS credentials
        id: aws-config
        continue-on-error: false
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION || 'us-east-1' }}
          mask-aws-account-id: true

      - name: Verify AWS configuration
        run: |
          echo "üîê Verifying AWS configuration..."
          aws sts get-caller-identity || {
            echo "‚ùå AWS credentials not configured properly"
            echo "Please ensure AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, and AWS_REGION secrets are set"
            exit 1
          }
          echo "‚úÖ AWS credentials verified"

      - name: Setup Node.js with flexible caching
        id: setup-node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          # Don't specify cache here - we'll handle it manually to avoid errors

      - name: Detect package manager and setup caching
        id: package-manager
        run: |
          echo "üîç Detecting package manager and dependency files..."

          # Detect package manager
          if [[ -f "yarn.lock" ]]; then
            PACKAGE_MANAGER="yarn"
            LOCK_FILE="yarn.lock"
            echo "üì¶ Detected: Yarn"
          elif [[ -f "pnpm-lock.yaml" ]]; then
            PACKAGE_MANAGER="pnpm"
            LOCK_FILE="pnpm-lock.yaml"
            echo "üì¶ Detected: PNPM"
          elif [[ -f "package-lock.json" ]]; then
            PACKAGE_MANAGER="npm"
            LOCK_FILE="package-lock.json"
            echo "üì¶ Detected: NPM"
          elif [[ -f "package.json" ]]; then
            PACKAGE_MANAGER="npm"
            LOCK_FILE=""
            echo "üì¶ Detected: NPM (no lock file)"
          else
            PACKAGE_MANAGER="none"
            LOCK_FILE=""
            echo "üì¶ No package.json found - skipping Node.js dependency management"
          fi

          echo "package_manager=$PACKAGE_MANAGER" >> $GITHUB_OUTPUT
          echo "lock_file=$LOCK_FILE" >> $GITHUB_OUTPUT

          # Setup manual caching if dependencies exist
          if [[ "$PACKAGE_MANAGER" != "none" ]]; then
            echo "üîß Setting up manual dependency caching..."
            
            # Create cache key
            if [[ -n "$LOCK_FILE" && -f "$LOCK_FILE" ]]; then
              CACHE_KEY="node-deps-${{ runner.os }}-$PACKAGE_MANAGER-$(shasum -a 256 $LOCK_FILE | cut -d' ' -f1)"
            else
              CACHE_KEY="node-deps-${{ runner.os }}-$PACKAGE_MANAGER-$(shasum -a 256 package.json | cut -d' ' -f1)"
            fi
            
            echo "cache_key=$CACHE_KEY" >> $GITHUB_OUTPUT
            echo "‚úÖ Cache key: $CACHE_KEY"
          fi

      - name: Cache Node.js dependencies
        if: steps.package-manager.outputs.package_manager != 'none'
        uses: actions/cache@v4
        with:
          path: |
            ~/.npm
            ~/.yarn
            ~/.cache/yarn
            ~/.pnpm
            node_modules
            */node_modules
          key: ${{ steps.package-manager.outputs.cache_key }}
          restore-keys: |
            node-deps-${{ runner.os }}-${{ steps.package-manager.outputs.package_manager }}-

      - name: Setup Python with flexible caching
        id: setup-python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"
          # Don't specify cache here - we'll handle it manually to avoid errors

      - name: Detect Python dependencies and setup caching
        id: python-deps
        run: |
          echo "üîç Detecting Python dependency files..."

          # Detect Python dependency files
          PYTHON_DEPS_FOUND="false"
          PYTHON_CACHE_KEY=""

          if [[ -f "requirements.txt" ]]; then
            PYTHON_DEPS_FOUND="true"
            PYTHON_CACHE_KEY="python-deps-${{ runner.os }}-requirements-$(shasum -a 256 requirements.txt | cut -d' ' -f1)"
            echo "üì¶ Found: requirements.txt"
          elif [[ -f "pyproject.toml" ]]; then
            PYTHON_DEPS_FOUND="true"
            PYTHON_CACHE_KEY="python-deps-${{ runner.os }}-pyproject-$(shasum -a 256 pyproject.toml | cut -d' ' -f1)"
            echo "üì¶ Found: pyproject.toml"
          elif [[ -f "Pipfile" ]]; then
            PYTHON_DEPS_FOUND="true"
            PYTHON_CACHE_KEY="python-deps-${{ runner.os }}-pipfile-$(shasum -a 256 Pipfile | cut -d' ' -f1)"
            echo "üì¶ Found: Pipfile"
          elif [[ -f "setup.py" ]]; then
            PYTHON_DEPS_FOUND="true"
            PYTHON_CACHE_KEY="python-deps-${{ runner.os }}-setup-$(shasum -a 256 setup.py | cut -d' ' -f1)"
            echo "üì¶ Found: setup.py"
          else
            echo "üìÑ No Python dependency files found - will install audit dependencies only"
          fi

          echo "python_deps_found=$PYTHON_DEPS_FOUND" >> $GITHUB_OUTPUT
          echo "python_cache_key=$PYTHON_CACHE_KEY" >> $GITHUB_OUTPUT

          if [[ "$PYTHON_DEPS_FOUND" == "true" ]]; then
            echo "‚úÖ Python cache key: $PYTHON_CACHE_KEY"
          fi

      - name: Cache Python dependencies
        if: steps.python-deps.outputs.python_deps_found == 'true'
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/pip
            ~/.local/lib/python*/site-packages
          key: ${{ steps.python-deps.outputs.python_cache_key }}
          restore-keys: |
            python-deps-${{ runner.os }}-

      - name: Install system dependencies
        run: |
          echo "üîß Installing system dependencies..."

          # Update package lists
          sudo apt-get update -qq

          # Install essential tools
          sudo apt-get install -y --no-install-recommends \
            curl \
            jq \
            tree \
            git \
            python3-pip \
            python3-venv \
            build-essential

          echo "‚úÖ System dependencies installed"

      - name: Install GitHub CLI
        run: |
          echo "üì• Installing GitHub CLI..."

          # Install GitHub CLI with retry logic
          for i in {1..3}; do
            if curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | \
               sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg 2>/dev/null && \
               sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg && \
               echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | \
               sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null && \
               sudo apt-get update -qq && \
               sudo apt-get install -y gh; then
              echo "‚úÖ GitHub CLI installed successfully"
              break
            else
              echo "‚ö†Ô∏è Attempt $i failed, retrying..."
              sleep 5
            fi
          done

          # Verify installation
          gh version || {
            echo "‚ùå GitHub CLI installation failed"
            exit 1
          }

      - name: Install Node.js dependencies
        if: steps.package-manager.outputs.package_manager != 'none'
        continue-on-error: false
        run: |
          echo "üì¶ Installing Node.js dependencies..."

          PACKAGE_MANAGER="${{ steps.package-manager.outputs.package_manager }}"
          LOCK_FILE="${{ steps.package-manager.outputs.lock_file }}"

          echo "Using package manager: $PACKAGE_MANAGER"

          # Install dependencies based on detected package manager
          case "$PACKAGE_MANAGER" in
            "yarn")
              echo "üß∂ Installing with Yarn..."
              # Install yarn if not present
              if ! command -v yarn &> /dev/null; then
                npm install -g yarn
              fi
              
              for i in {1..3}; do
                if yarn install --frozen-lockfile --silent; then
                  echo "‚úÖ Yarn dependencies installed successfully"
                  break
                else
                  echo "‚ö†Ô∏è Yarn install attempt $i failed, retrying..."
                  rm -rf node_modules yarn.lock.tmp
                  sleep 5
                  if [[ $i -eq 3 ]]; then
                    echo "‚ùå Yarn install failed, trying fallback..."
                    yarn install --silent || echo "Continuing without dependencies..."
                  fi
                fi
              done
              ;;
              
            "pnpm")
              echo "üì¶ Installing with PNPM..."
              # Install pnpm if not present
              if ! command -v pnpm &> /dev/null; then
                npm install -g pnpm
              fi
              
              for i in {1..3}; do
                if pnpm install --frozen-lockfile; then
                  echo "‚úÖ PNPM dependencies installed successfully"
                  break
                else
                  echo "‚ö†Ô∏è PNPM install attempt $i failed, retrying..."
                  rm -rf node_modules
                  sleep 5
                  if [[ $i -eq 3 ]]; then
                    echo "‚ùå PNPM install failed, trying fallback..."
                    pnpm install || echo "Continuing without dependencies..."
                  fi
                fi
              done
              ;;
              
            "npm")
              echo "üì¶ Installing with NPM..."
              
              # Choose install strategy based on lock file existence
              if [[ -n "$LOCK_FILE" && -f "$LOCK_FILE" ]]; then
                # Use npm ci for clean install with lock file
                for i in {1..3}; do
                  if npm ci --silent --no-audit --no-fund; then
                    echo "‚úÖ NPM dependencies installed successfully (clean install)"
                    break
                  else
                    echo "‚ö†Ô∏è NPM ci attempt $i failed, cleaning and retrying..."
                    rm -rf node_modules
                    sleep 5
                    if [[ $i -eq 3 ]]; then
                      echo "‚ùå NPM ci failed, trying npm install..."
                      npm install --silent --no-audit --no-fund || {
                        echo "‚ùå NPM install fallback also failed"
                        echo "Continuing without Node.js dependencies..."
                      }
                    fi
                  fi
                done
              else
                # Use npm install when no lock file exists
                for i in {1..3}; do
                  if npm install --silent --no-audit --no-fund; then
                    echo "‚úÖ NPM dependencies installed successfully"
                    break
                  else
                    echo "‚ö†Ô∏è NPM install attempt $i failed, retrying..."
                    rm -rf node_modules
                    sleep 5
                    if [[ $i -eq 3 ]]; then
                      echo "‚ùå NPM install failed after 3 attempts"
                      echo "Continuing without Node.js dependencies..."
                    fi
                  fi
                done
              fi
              ;;
              
            *)
              echo "‚ùå Unknown package manager: $PACKAGE_MANAGER"
              echo "Continuing without Node.js dependencies..."
              ;;
          esac

          # Verify installation
          if [[ -d "node_modules" ]]; then
            echo "‚úÖ Node.js dependencies verification passed"
          else
            echo "‚ö†Ô∏è No node_modules directory found, but continuing..."
          fi

      - name: Skip Node.js dependencies
        if: steps.package-manager.outputs.package_manager == 'none'
        run: |
          echo "üìÑ No package.json found, skipping Node.js dependencies installation"

      - name: Install Python dependencies
        continue-on-error: false
        run: |
          echo "üêç Installing Python dependencies..."

          # Upgrade pip first
          python3 -m pip install --upgrade pip setuptools wheel

          # Install project-specific dependencies if they exist
          PYTHON_DEPS_FOUND="${{ steps.python-deps.outputs.python_deps_found }}"

          if [[ "$PYTHON_DEPS_FOUND" == "true" ]]; then
            echo "üì¶ Installing project Python dependencies..."
            
            # Install based on available dependency files
            if [[ -f "requirements.txt" ]]; then
              echo "Installing from requirements.txt..."
              python3 -m pip install -r requirements.txt || {
                echo "‚ö†Ô∏è Failed to install project requirements, continuing with audit dependencies..."
              }
            elif [[ -f "pyproject.toml" ]]; then
              echo "Installing from pyproject.toml..."
              python3 -m pip install . || {
                echo "‚ö†Ô∏è Failed to install project from pyproject.toml, continuing with audit dependencies..."
              }
            elif [[ -f "Pipfile" ]]; then
              echo "Installing pipenv and dependencies..."
              python3 -m pip install pipenv
              pipenv install --dev || {
                echo "‚ö†Ô∏è Failed to install from Pipfile, continuing with audit dependencies..."
              }
            elif [[ -f "setup.py" ]]; then
              echo "Installing from setup.py..."
              python3 -m pip install -e . || {
                echo "‚ö†Ô∏è Failed to install from setup.py, continuing with audit dependencies..."
              }
            fi
          else
            echo "üìÑ No Python project dependencies found, installing audit dependencies only"
          fi

          # Always install required audit dependencies with retry logic
          echo "üîß Installing Claude audit dependencies..."
          for i in {1..3}; do
            if python3 -m pip install --no-cache-dir \
              boto3>=1.34.0 \
              requests>=2.31.0 \
              botocore>=1.34.0 \
              PyGithub>=2.1.0; then
              echo "‚úÖ Claude audit dependencies installed successfully"
              break
            else
              echo "‚ö†Ô∏è Audit dependencies install attempt $i failed, retrying..."
              sleep 5
              if [[ $i -eq 3 ]]; then
                echo "‚ùå Claude audit dependencies installation failed"
                exit 1
              fi
            fi
          done

          # Verify critical installations
          python3 -c "import boto3, requests, github; print('‚úÖ All required audit modules imported successfully')"

      - name: Analyze codebase structure
        run: |
          echo "üîç Analyzing codebase structure..."

          # Find all relevant source files including React Native specific files
          find . -type f \( \
            -name "*.ts" -o -name "*.tsx" -o -name "*.js" -o -name "*.jsx" -o \
            -name "*.css" -o -name "*.scss" -o -name "*.sass" -o -name "*.less" -o \
            -name "*.json" -o -name "*.md" -o -name "*.yml" -o -name "*.yaml" -o \
            -name "*.swift" -o -name "*.java" -o -name "*.kt" -o -name "*.m" -o \
            -name "*.h" -o -name "*.py" -o -name "*.rb" -o -name "*.gradle" -o \
            -name "*.xml" -o -name "*.plist" -o -name "*.podspec" \
          \) \
            -not -path "./node_modules/*" \
            -not -path "./.git/*" \
            -not -path "./dist/*" \
            -not -path "./build/*" \
            -not -path "./android/build/*" \
            -not -path "./ios/build/*" \
            -not -path "./android/.gradle/*" \
            -not -path "./.expo/*" \
            -not -path "./coverage/*" \
            -not -path "./.nyc_output/*" > codebase_files.txt

          echo "üìÅ Found $(wc -l < codebase_files.txt) files to analyze"

          # Detect project type
          PROJECT_TYPE="unknown"
          if [[ -f "package.json" ]]; then
            if grep -q "react-native" package.json; then
              PROJECT_TYPE="react-native"
            elif grep -q "@expo" package.json; then
              PROJECT_TYPE="expo"
            elif grep -q "react" package.json; then
              PROJECT_TYPE="react"
            elif grep -q "next" package.json; then
              PROJECT_TYPE="nextjs"
            elif grep -q "vue" package.json; then
              PROJECT_TYPE="vue"
            else
              PROJECT_TYPE="nodejs"
            fi
          elif [[ -f "pubspec.yaml" ]]; then
            PROJECT_TYPE="flutter"
          elif [[ -f "requirements.txt" ]] || [[ -f "pyproject.toml" ]]; then
            PROJECT_TYPE="python"
          fi

          echo "üì± Detected project type: $PROJECT_TYPE"

          # Create project structure context
          echo "Project structure analysis:" > project_structure.txt
          echo "=========================" >> project_structure.txt
          echo "Project Type: $PROJECT_TYPE" >> project_structure.txt
          echo "" >> project_structure.txt

          # Use tree with React Native specific exclusions
          tree -I 'node_modules|.git|dist|build|android/build|ios/build|.expo|coverage|.nyc_output|.gradle' -L 4 >> project_structure.txt 2>/dev/null || {
            echo "Tree not available, using find instead:" >> project_structure.txt
            find . -type d \
              -not -path "./node_modules*" \
              -not -path "./.git*" \
              -not -path "./android/build*" \
              -not -path "./ios/build*" \
              -not -path "./.expo*" \
              | head -50 >> project_structure.txt
          }

          # Analyze dependencies with React Native awareness
          echo "Dependencies analysis:" > dependencies_analysis.txt
          echo "=====================" >> dependencies_analysis.txt
          echo "Project Type: $PROJECT_TYPE" >> dependencies_analysis.txt
          echo "" >> dependencies_analysis.txt

          if [[ -f "package.json" ]]; then
            echo "Package.json dependencies:" >> dependencies_analysis.txt
            jq '.dependencies // {}' package.json >> dependencies_analysis.txt
            echo "" >> dependencies_analysis.txt
            echo "DevDependencies:" >> dependencies_analysis.txt
            jq '.devDependencies // {}' package.json >> dependencies_analysis.txt
          fi

      - name: Run Claude AI Code Audit
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          AWS_BEDROCK_MODEL_ID: ${{ secrets.AWS_BEDROCK_MODEL_ID || 'us.anthropic.claude-3-5-sonnet-20241022-v2:0' }}
          AUDIT_SCOPE: ${{ env.AUDIT_SCOPE }}
          INCLUDE_SUGGESTIONS: ${{ env.INCLUDE_SUGGESTIONS }}
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
          IS_FORK: ${{ steps.repo-info.outputs.is_fork }}
          TARGET_REPO_OWNER: ${{ steps.repo-info.outputs.target_repo_owner }}
          TARGET_REPO_NAME: ${{ steps.repo-info.outputs.target_repo_name }}
          TARGET_BRANCH: ${{ steps.repo-info.outputs.target_branch }}
          AUDIT_BRANCH: ${{ steps.repo-info.outputs.audit_branch }}
        run: |
          cat << 'EOF' > claude_auditor.py
          import boto3
          import json
          import os
          import subprocess
          import time
          import random
          import sys
          from datetime import datetime
          from botocore.config import Config
          from github import Github, GithubException
          import re

          class RobustClaudeCodeAuditor:
              def __init__(self):
                  self.github_token = os.environ['GITHUB_TOKEN']
                  self.bedrock_client = self.get_bedrock_client()
                  self.model_id = os.environ.get('AWS_BEDROCK_MODEL_ID', 'us.anthropic.claude-3-5-sonnet-20241022-v2:0')
                  self.audit_scope = os.environ.get('AUDIT_SCOPE', 'all')
                  self.include_suggestions = os.environ.get('INCLUDE_SUGGESTIONS', 'true').lower() == 'true'
                  
                  # Repository information
                  self.current_repo_owner = os.environ['REPO_OWNER']
                  self.current_repo_name = os.environ['REPO_NAME']
                  self.is_fork = os.environ.get('IS_FORK', 'false').lower() == 'true'
                  self.target_repo_owner = os.environ.get('TARGET_REPO_OWNER', self.current_repo_owner)
                  self.target_repo_name = os.environ.get('TARGET_REPO_NAME', self.current_repo_name)
                  self.target_branch = os.environ.get('TARGET_BRANCH', 'main')
                  self.audit_branch = os.environ.get('AUDIT_BRANCH', f"claude-audit-{int(time.time())}")
                  
                  print(f"üèóÔ∏è Audit Configuration:")
                  print(f"   Current repo: {self.current_repo_owner}/{self.current_repo_name}")
                  print(f"   Target repo: {self.target_repo_owner}/{self.target_repo_name}")
                  print(f"   Target branch: {self.target_branch}")
                  print(f"   Audit branch: {self.audit_branch}")
                  print(f"   Is fork: {self.is_fork}")
                  
              def get_bedrock_client(self):
                  """Initialize Bedrock client with robust error handling"""
                  try:
                      config = Config(
                          read_timeout=300,
                          connect_timeout=30,
                          retries={
                              'max_attempts': 10,
                              'mode': 'adaptive'
                          }
                      )
                      client = boto3.client('bedrock-runtime', config=config)
                      
                      # Test the connection
                      try:
                          client.list_foundation_models()
                          print("‚úÖ AWS Bedrock client initialized successfully")
                      except Exception as e:
                          print(f"‚ö†Ô∏è Bedrock connection test failed: {e}")
                          
                      return client
                  except Exception as e:
                      print(f"‚ùå Failed to initialize Bedrock client: {e}")
                      sys.exit(1)

              def read_file_safely(self, filepath, max_lines=200):
                  """Read file content safely with robust error handling"""
                  try:
                      with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                          lines = f.readlines()
                          if len(lines) > max_lines:
                              return ''.join(lines[:max_lines]) + f'\n... (truncated, {len(lines)-max_lines} more lines)'
                          return ''.join(lines)
                  except Exception as e:
                      return f"Error reading file {filepath}: {str(e)}"

              def analyze_codebase_structure(self):
                  """Analyze codebase with enhanced error handling"""
                  print("üìä Analyzing codebase structure...")
                  
                  context = {
                      'project_structure': '',
                      'key_files': {},
                      'source_files': [],
                      'dependencies': '',
                      'file_stats': {}
                  }
                  
                  try:
                      # Read project structure
                      if os.path.exists('project_structure.txt'):
                          context['project_structure'] = self.read_file_safely('project_structure.txt', 100)
                      
                      # Read dependencies analysis
                      if os.path.exists('dependencies_analysis.txt'):
                          context['dependencies'] = self.read_file_safely('dependencies_analysis.txt', 50)
                      
                      # Read key configuration files
                      key_files = [
                          'package.json', 'tsconfig.json', 'vite.config.ts', 'vite.config.js',
                          'capacitor.config.ts', 'ionic.config.json', '.eslintrc.json',
                          '.eslintrc.js', 'webpack.config.js', 'next.config.js',
                          'tailwind.config.js', 'postcss.config.js', 'jest.config.js',
                          'requirements.txt', 'Pipfile', 'pyproject.toml', 'setup.py',
                          'Dockerfile', 'docker-compose.yml', '.gitignore', 'README.md'
                      ]
                      
                      for file in key_files:
                          if os.path.exists(file):
                              context['key_files'][file] = self.read_file_safely(file, 100)
                      
                      # Read source files list
                      if os.path.exists('codebase_files.txt'):
                          with open('codebase_files.txt', 'r') as f:
                              context['source_files'] = [line.strip() for line in f.readlines() if line.strip()]
                      
                      # Calculate comprehensive file statistics
                      total_files = len(context['source_files'])
                      ts_files = len([f for f in context['source_files'] if f.endswith(('.ts', '.tsx'))])
                      js_files = len([f for f in context['source_files'] if f.endswith(('.js', '.jsx'))])
                      css_files = len([f for f in context['source_files'] if f.endswith(('.css', '.scss', '.sass', '.less'))])
                      py_files = len([f for f in context['source_files'] if f.endswith('.py')])
                      md_files = len([f for f in context['source_files'] if f.endswith('.md')])
                      json_files = len([f for f in context['source_files'] if f.endswith('.json')])
                      
                      context['file_stats'] = {
                          'total': total_files,
                          'typescript': ts_files,
                          'javascript': js_files,
                          'css': css_files,
                          'python': py_files,
                          'markdown': md_files,
                          'json': json_files
                      }
                      
                      print(f"‚úÖ Analyzed {total_files} files")
                      
                  except Exception as e:
                      print(f"‚ö†Ô∏è Error in codebase analysis: {e}")
                  
                  return context

              def sample_source_files(self, source_files, max_files=30):
                  """Sample source files with improved prioritization"""
                  print(f"üìÇ Sampling up to {max_files} source files for detailed analysis...")
                  
                  if not source_files:
                      print("‚ö†Ô∏è No source files found")
                      return {}
                  
                  # Enhanced priority patterns
                  priority_patterns = [
                      (r'src/.*\.(tsx?|jsx?)$', 10),  # React/TS components (highest priority)
                      (r'.*service.*\.(ts|js)$', 9),    # Services
                      (r'.*api.*\.(ts|js)$', 9),        # API related
                      (r'.*util.*\.(ts|js)$', 8),       # Utilities
                      (r'.*hook.*\.(ts|js)$', 8),       # Hooks
                      (r'.*context.*\.(tsx?|jsx?)$', 8), # Contexts
                      (r'.*config.*\.(ts|js)$', 7),     # Configuration
                      (r'.*component.*\.(tsx?|jsx?)$', 7), # Components
                      (r'.*\.css$', 6),                 # Styles
                      (r'.*test.*\.(ts|js)$', 5),       # Tests
                      (r'.*\.md$', 4),                  # Documentation
                      (r'.*\.json$', 3),                # JSON files
                  ]
                  
                  scored_files = []
                  
                  for file in source_files:
                      score = 1  # Default score
                      for pattern, pattern_score in priority_patterns:
                          if re.search(pattern, file, re.IGNORECASE):
                              score = pattern_score
                              break
                      scored_files.append((file, score))
                  
                  # Sort by score (highest first)
                  scored_files.sort(key=lambda x: x[1], reverse=True)
                  selected_files = [f[0] for f in scored_files[:max_files]]
                  
                  file_contents = {}
                  for file_path in selected_files:
                      if os.path.exists(file_path):
                          content = self.read_file_safely(file_path, 200)
                          file_contents[file_path] = content
                          
                  print(f"‚úÖ Successfully sampled {len(file_contents)} files")
                  return file_contents

              def perform_audit_with_claude(self, codebase_context, sampled_files):
                  """Enhanced Claude audit with better prompting"""
                  
                  scope_descriptions = {
                      'all': 'Complete codebase audit covering security, maintainability, performance, and cleanup',
                      'security': 'Security-focused audit for vulnerabilities and unsafe patterns',
                      'performance': 'Performance audit for optimization opportunities',
                      'maintainability': 'Maintainability audit for code quality and structure',
                      'cleanup': 'Cleanup audit for dead code and unused dependencies'
                  }
                  
                  # Build comprehensive audit prompt
                  audit_prompt = self.build_audit_prompt(codebase_context, sampled_files, scope_descriptions)
                  
                  return self.generate_with_retry(audit_prompt)

              def build_audit_prompt(self, codebase_context, sampled_files, scope_descriptions):
                  """Build a comprehensive audit prompt"""
                  
                  audit_prompt = f"""You are an expert code auditor specializing in modern web development, including TypeScript, React, Node.js, Python, and cloud applications. 
          You are performing a {scope_descriptions.get(self.audit_scope, 'comprehensive')} audit of a software project.

          ## AUDIT SCOPE: {self.audit_scope.upper()}

          ## PROJECT OVERVIEW
          **File Statistics:**
          - Total files: {codebase_context['file_stats']['total']}
          - TypeScript files: {codebase_context['file_stats']['typescript']}
          - JavaScript files: {codebase_context['file_stats']['javascript']}
          - Python files: {codebase_context['file_stats']['python']}
          - CSS files: {codebase_context['file_stats']['css']}
          - Markdown files: {codebase_context['file_stats']['markdown']}
          - JSON files: {codebase_context['file_stats']['json']}

          **Project Structure:**
          ```
          {codebase_context['project_structure']}
          ```

          **Dependencies:**
          ```
          {codebase_context['dependencies']}
          ```

          ## CONFIGURATION FILES"""
                  
                  for file, content in codebase_context['key_files'].items():
                      audit_prompt += f"\n**{file}:**\n```\n{content}\n```\n"
                  
                  audit_prompt += "\n## SOURCE CODE SAMPLES\n"
                  
                  for file_path, content in sampled_files.items():
                      audit_prompt += f"\n**{file_path}:**\n```\n{content}\n```\n"
                  
                  # Add comprehensive audit criteria
                  audit_prompt += self.get_audit_criteria()
                  
                  # Add output format
                  audit_prompt += self.get_output_format()
                  
                  return audit_prompt

              def get_audit_criteria(self):
                  """Get audit criteria based on scope"""
                  criteria = ""
                  
                  if self.audit_scope == 'all' or self.audit_scope == 'security':
                      criteria += """

          ## üîê SECURITY AUDIT CRITERIA
          1. **Input Validation & Sanitization:**
             - Unvalidated user inputs, missing sanitization, injection vulnerabilities
          2. **Authentication & Authorization:**
             - Weak auth patterns, missing checks, session handling
          3. **Data Protection:**
             - Sensitive data exposure, insecure storage, missing encryption
          4. **Dependencies & Configuration:**
             - Vulnerable dependencies, hardcoded secrets, insecure configs
          """

                  if self.audit_scope == 'all' or self.audit_scope == 'maintainability':
                      criteria += """

          ## üõ†Ô∏è MAINTAINABILITY AUDIT CRITERIA
          1. **Code Complexity & Structure:**
             - Complex functions, deep nesting, unclear logic, architectural issues
          2. **Code Quality:**
             - Naming conventions, documentation, typing, consistency
          3. **Architecture:**
             - Dependencies, coupling, abstractions, separation of concerns
          4. **Duplication & Redundancy:**
             - Duplicate code, similar patterns, redundant components
          """

                  if self.audit_scope == 'all' or self.audit_scope == 'performance':
                      criteria += """

          ## üöÄ PERFORMANCE AUDIT CRITERIA
          1. **Rendering & UI Performance:**
             - Re-renders, memoization opportunities, component optimization
          2. **Data & API Efficiency:**
             - API calls, caching, payload sizes, async operations
          3. **Resource Management:**
             - Memory leaks, cleanup, bundle sizes, asset optimization
          4. **Algorithms & Data Structures:**
             - Inefficient loops, poor data structures, redundant computations
          """

                  if self.audit_scope == 'all' or self.audit_scope == 'cleanup':
                      criteria += """

          ## üßπ CLEANUP AUDIT CRITERIA
          1. **Dead Code Elimination:**
             - Unused functions/variables, unreachable code, commented code
          2. **Dependency Management:**
             - Unused packages, outdated deps, vulnerabilities, duplicates
          3. **File & Asset Management:**
             - Unused files, duplicate assets, legacy code, test artifacts
          """
                  
                  return criteria

              def get_output_format(self):
                  """Get the structured output format"""
                  format_template = f"""

          ## AUDIT INSTRUCTIONS
          Create a comprehensive, actionable audit report in the following format:

          # üîç Claude AI Code Audit Report

          **Project:** Software Application Audit
          **Audit Date:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
          **Audit Scope:** {self.audit_scope.title()}
          **Repository:** {self.target_repo_owner}/{self.target_repo_name}
          **Files Analyzed:** {"{len(sampled_files)}"} sampled files

          ## üìä Executive Summary
          [Brief overview of findings, overall code health score (1-10), and key recommendations]

          ## üîç Detailed Findings

          ### üîê Security Issues
          [List security findings with severity: CRITICAL üö®, HIGH üî¥, MEDIUM üü°, LOW üü¢]

          ### üõ†Ô∏è Maintainability Issues  
          [Code quality, structure, and maintainability concerns]

          ### üöÄ Performance Issues
          [Performance bottlenecks and optimization opportunities]

          ### üßπ Cleanup Opportunities
          [Dead code, unused dependencies, and cleanup tasks]

          ## üìà Code Quality Metrics
          [File counts, complexity estimates, technical debt indicators]

          ## ‚úÖ Positive Findings
          [Highlight well-implemented patterns and good practices]
          """

                  if self.include_suggestions:
                      format_template += """

          ## üí° Improvement Recommendations

          ### Priority 1 - Critical/High Impact
          [Most important fixes with implementation steps]

          ### Priority 2 - Medium Impact
          [Important improvements for code quality]

          ### Priority 3 - Low Impact/Nice-to-Have
          [Optional improvements and optimizations]

          ## üõ†Ô∏è Implementation Roadmap
          [Step-by-step guide for addressing key issues]
          """

                  format_template += """

          ## üìã Action Items Checklist
          - [ ] Review critical security issues
          - [ ] Address high-priority performance problems
          - [ ] Implement maintainability improvements
          - [ ] Clean up dead code and unused dependencies
          - [ ] Update documentation
          - [ ] Schedule follow-up audit

          ---
          *Report generated by Claude AI Code Auditor ü§ñ*

          **Instructions:** Provide specific examples with file names and line references. Be thorough but concise. Focus on actionable insights that will genuinely improve the codebase.
          """
                  
                  return format_template

              def generate_with_retry(self, prompt, max_retries=15):
                  """Enhanced generation with better retry logic"""
                  print("ü§ñ Sending audit request to Claude AI...")
                  print(f"üìù Prompt length: {len(prompt):,} characters")
                  print(f"üéØ Using model: {self.model_id}")
                  print("=" * 80)
                  
                  for attempt in range(max_retries):
                      try:
                          print(f"üöÄ Attempt {attempt + 1}/{max_retries}")
                          
                          body = {
                              "anthropic_version": "bedrock-2023-05-31",
                              "max_tokens": 20000,
                              "temperature": 0.3,
                              "messages": [
                                  {
                                      "role": "user",
                                      "content": prompt
                                  }
                              ]
                          }
                          
                          start_time = time.time()
                          response = self.bedrock_client.invoke_model(
                              body=json.dumps(body),
                              modelId=self.model_id,
                              accept='application/json',
                              contentType='application/json'
                          )
                          
                          response_body = json.loads(response.get('body').read())
                          audit_report = response_body['content'][0]['text']
                          
                          generation_time = time.time() - start_time
                          
                          print(f"‚úÖ Audit completed in {generation_time:.2f} seconds!")
                          print(f"üìä Report length: {len(audit_report):,} characters")
                          print("=" * 80)
                          
                          return audit_report
                          
                      except Exception as e:
                          error_str = str(e)
                          print(f"‚ùå Attempt {attempt + 1} failed: {error_str}")
                          
                          # Different retry delays based on error type
                          if "throttling" in error_str.lower() or "rate" in error_str.lower():
                              delay = min(30 + (attempt * 10), 120)  # Longer delay for rate limits
                          else:
                              delay = min(2 ** attempt + random.uniform(0, 1), 60)
                          
                          if attempt < max_retries - 1:
                              print(f"‚è≥ Waiting {delay:.2f} seconds before retry...")
                              time.sleep(delay)
                          else:
                              print("‚ùå All retry attempts exhausted")
                              return None
                  
                  return None

              def save_audit_report(self, audit_report):
                  """Save audit report with timestamp"""
                  print("üíæ Saving audit report...")
                  
                  # Create audit directory
                  audit_dir = '.github/claude-audits'
                  os.makedirs(audit_dir, exist_ok=True)
                  
                  # Save with timestamp
                  timestamp = datetime.now().strftime('%Y%m%d-%H%M%S')
                  audit_file_path = f'{audit_dir}/audit-{timestamp}.md'
                  
                  with open(audit_file_path, 'w', encoding='utf-8') as f:
                      f.write(audit_report)
                  
                  # Also save as latest
                  latest_path = f'{audit_dir}/latest-audit.md'
                  with open(latest_path, 'w', encoding='utf-8') as f:
                      f.write(audit_report)
                  
                  print(f"‚úÖ Audit report saved to {audit_file_path}")
                  return audit_file_path, latest_path

              def create_branch_and_commit(self, audit_file_path, latest_path):
                  """Create branch and commit with robust error handling"""
                  try:
                      print(f"üåø Creating branch: {self.audit_branch}")
                      
                      # Configure git
                      subprocess.run(['git', 'config', 'user.name', 'Claude AI Auditor'], check=True)
                      subprocess.run(['git', 'config', 'user.email', 'claude-auditor@github-actions.bot'], check=True)
                      
                      # Create and checkout new branch
                      subprocess.run(['git', 'checkout', '-b', self.audit_branch], check=True)
                      
                      # Add the audit reports
                      subprocess.run(['git', 'add', audit_file_path, latest_path], check=True)
                      
                      commit_msg = f"""üîç Claude AI Code Audit Report

          üìã Audit Details:
          - Scope: {self.audit_scope}
          - Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
          - Target: {self.target_repo_owner}/{self.target_repo_name}:{self.target_branch}
          - Report: {audit_file_path}

          üéØ Analysis Coverage:
          üîê Security vulnerabilities and best practices
          üõ†Ô∏è Code quality and maintainability 
          üöÄ Performance optimization opportunities
          üßπ Dead code and cleanup recommendations

          Generated by Claude AI Code Auditor ü§ñ
          """
                      
                      subprocess.run(['git', 'commit', '-m', commit_msg], check=True)
                      subprocess.run(['git', 'push', '-u', 'origin', self.audit_branch], check=True)
                      
                      print(f"‚úÖ Successfully pushed to branch: {self.audit_branch}")
                      return True
                      
                  except subprocess.CalledProcessError as e:
                      print(f"‚ùå Git operation failed: {e}")
                      return False

              def create_pull_request(self, audit_file_path):
                  """Create pull request with enhanced fork handling"""
                  try:
                      print("üìù Creating pull request...")
                      
                      github_client = Github(self.github_token)
                      
                      if self.is_fork:
                          # For forks, create PR from fork to upstream
                          source_repo = github_client.get_repo(f"{self.current_repo_owner}/{self.current_repo_name}")
                          target_repo = github_client.get_repo(f"{self.target_repo_owner}/{self.target_repo_name}")
                          head = f"{self.current_repo_owner}:{self.audit_branch}"
                          base = self.target_branch
                          repo_for_pr = target_repo
                          print(f"üç¥ Creating PR from fork {head} to {self.target_repo_owner}/{self.target_repo_name}:{base}")
                      else:
                          # For original repos, create PR within the same repo
                          repo_for_pr = github_client.get_repo(f"{self.current_repo_owner}/{self.current_repo_name}")
                          head = self.audit_branch
                          base = self.target_branch
                          print(f"üìÅ Creating PR within repo {head} to {base}")
                      
                      pr_title = f"üîç Claude AI Code Audit Report - {datetime.now().strftime('%Y-%m-%d')}"
                      pr_body = self.generate_pr_body(audit_file_path)
                      
                      try:
                          pull_request = repo_for_pr.create_pull(
                              title=pr_title,
                              body=pr_body,
                              head=head,
                              base=base
                          )
                          
                          # Add labels if possible
                          try:
                              available_labels = [label.name for label in repo_for_pr.get_labels()]
                              labels_to_add = []
                              
                              for label in ['claude-audit', 'code-quality', 'automated', 'audit']:
                                  if label in available_labels:
                                      labels_to_add.append(label)
                              
                              if labels_to_add:
                                  pull_request.add_to_labels(*labels_to_add)
                                  
                          except Exception as label_error:
                              print(f"‚ö†Ô∏è Could not add labels: {label_error}")
                          
                          print(f"‚úÖ Pull request created: {pull_request.html_url}")
                          return pull_request.html_url
                          
                      except GithubException as pr_error:
                          if pr_error.status == 422:
                              print("‚ö†Ô∏è PR already exists or validation error. Trying to find existing PR...")
                              return self.find_existing_pr(repo_for_pr)
                          else:
                              raise pr_error
                              
                  except Exception as e:
                      print(f"‚ùå Failed to create pull request: {e}")
                      return self.create_fallback_summary(audit_file_path)

              def find_existing_pr(self, repo):
                  """Find existing PR for the audit branch"""
                  try:
                      pulls = repo.get_pulls(state='open', head=f"{self.current_repo_owner}:{self.audit_branch}")
                      for pr in pulls:
                          print(f"‚úÖ Found existing PR: {pr.html_url}")
                          return pr.html_url
                  except:
                      pass
                  return None

              def generate_pr_body(self, audit_file_path):
                  """Generate comprehensive PR body"""
                  return f"""# üîç Claude AI Code Audit Report

          This pull request contains a comprehensive code audit report generated by Claude AI.

          ## üìã Audit Details
          - **Scope:** {self.audit_scope.title()}
          - **Date:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
          - **Report Location:** `{audit_file_path}`
          - **Target Repository:** {self.target_repo_owner}/{self.target_repo_name}
          - **Target Branch:** {self.target_branch}
          - **Repository Type:** {'Fork' if self.is_fork else 'Original'}
          - **Suggestions Included:** {'Yes' if self.include_suggestions else 'No'}

          ## üéØ Audit Coverage

          {'üîê **Security Analysis** - Vulnerability detection and security best practices' if self.audit_scope in ['all', 'security'] else ''}
          {'üõ†Ô∏è **Maintainability Review** - Code quality and structural improvements' if self.audit_scope in ['all', 'maintainability'] else ''}
          {'üöÄ **Performance Optimization** - Performance bottlenecks and optimization opportunities' if self.audit_scope in ['all', 'performance'] else ''}
          {'üßπ **Code Cleanup** - Dead code, unused dependencies, and cleanup recommendations' if self.audit_scope in ['all', 'cleanup'] else ''}

          ## üìñ How to Use This Report

          1. **üìã Review the findings** in the detailed audit report
          2. **üéØ Prioritize issues** based on severity levels (Critical üö®, High üî¥, Medium üü°, Low üü¢)
          3. **üìù Create issues** for specific problems that need fixing
          4. **üîß Implement suggestions** to improve code quality and security
          5. **üîÑ Schedule regular audits** to maintain code health

          ## ‚ö†Ô∏è Important Notes

          - **AI-Generated Content:** This audit was performed by AI and should be reviewed by human developers
          - **Context Matters:** Some findings may be false positives - use your domain knowledge
          - **Prioritize Wisely:** Not all issues need immediate fixing - focus on high-impact items
          - **Incremental Improvement:** Consider implementing changes gradually to avoid disruption

          ## üîÑ Next Steps

          1. **üìñ Review** the complete audit report in detail
          2. **üë• Discuss** findings with your development team
          3. **üìã Create** actionable tickets for priority issues
          4. **üìÖ Plan** implementation of recommended improvements
          5. **üîç Monitor** progress and schedule follow-up audits

          ## ü§ñ Automation Details

          - **Workflow:** Runs automatically every 6 hours
          - **Model:** Claude 3.5 Sonnet via AWS Bedrock
          - **Coverage:** Comprehensive analysis of codebase structure and patterns
          - **Reliability:** Multiple retry mechanisms and error handling

          ---
          *ü§ñ Generated automatically by Claude AI Code Auditor*
          *‚ö° Powered by AWS Bedrock and GitHub Actions*
          """

              def create_fallback_summary(self, audit_file_path):
                  """Create fallback summary when PR creation fails"""
                  summary_content = f"""# üîç Claude AI Code Audit Summary

          **‚úÖ Audit Completed:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
          **üåø Branch:** {self.audit_branch}
          **üìÑ Report:** {audit_file_path}
          **üéØ Scope:** {self.audit_scope.title()}
          **üèóÔ∏è Repository:** {self.target_repo_owner}/{self.target_repo_name}

          ## üìã Manual Steps Required

          1. **üìñ View the audit report:** `{audit_file_path}`
          2. **üîó Create a Pull Request manually:**
             - Go to [{self.target_repo_owner}/{self.target_repo_name}](https://github.com/{self.target_repo_owner}/{self.target_repo_name})
             - Switch to the `{self.audit_branch}` branch
             - Click "Compare & pull request"
             - Target branch: `{self.target_branch}`
          3. **üìù Review findings** and implement improvements

          ## üîó Quick Links

          - **üåø Branch:** [{self.audit_branch}](https://github.com/{self.current_repo_owner}/{self.current_repo_name}/tree/{self.audit_branch})
          - **üìÑ Report:** [{audit_file_path}](https://github.com/{self.current_repo_owner}/{self.current_repo_name}/blob/{self.audit_branch}/{audit_file_path})
          - **üéØ Target Repo:** [{self.target_repo_owner}/{self.target_repo_name}](https://github.com/{self.target_repo_owner}/{self.target_repo_name})

          ---
          *ü§ñ Generated by Claude AI Code Auditor*
          """
                  
                  summary_path = 'CLAUDE_AUDIT_SUMMARY.md'
                  with open(summary_path, 'w', encoding='utf-8') as f:
                      f.write(summary_content)
                  
                  try:
                      subprocess.run(['git', 'add', summary_path], check=True)
                      subprocess.run(['git', 'commit', '-m', 'Add audit summary'], check=True)
                      subprocess.run(['git', 'push'], check=True)
                      print(f"‚úÖ Fallback summary created: {summary_path}")
                  except:
                      print(f"‚ö†Ô∏è Could not commit summary, but file created: {summary_path}")
                  
                  return summary_path

              def run_audit(self):
                  """Main audit execution with comprehensive error handling"""
                  try:
                      print("üîç Starting Robust Claude AI Code Audit...")
                      print(f"üìã Audit scope: {self.audit_scope}")
                      print(f"üí° Include suggestions: {self.include_suggestions}")
                      print("=" * 80)
                      
                      # Step 1: Analyze codebase
                      codebase_context = self.analyze_codebase_structure()
                      
                      if not codebase_context['source_files']:
                          print("‚ö†Ô∏è No source files found. Creating minimal report...")
                          audit_report = self.create_minimal_report()
                      else:
                          # Step 2: Sample files
                          sampled_files = self.sample_source_files(codebase_context['source_files'])
                          
                          # Step 3: Perform audit
                          audit_report = self.perform_audit_with_claude(codebase_context, sampled_files)
                          
                          if not audit_report:
                              print("‚ùå Failed to generate audit report")
                              return False
                      
                      # Step 4: Save report
                      audit_file_path, latest_path = self.save_audit_report(audit_report)
                      
                      # Step 5: Create branch and commit
                      if self.create_branch_and_commit(audit_file_path, latest_path):
                          # Step 6: Create PR
                          pr_url = self.create_pull_request(audit_file_path)
                          if pr_url:
                              print(f"üéâ Audit completed successfully!")
                              print(f"üîó Pull Request: {pr_url}")
                          else:
                              print("‚ö†Ô∏è PR creation failed, but audit completed")
                      else:
                          print("‚ùå Failed to create branch and commit")
                          return False
                      
                      return True
                      
                  except Exception as e:
                      print(f"üí• Critical error in audit execution: {e}")
                      import traceback
                      traceback.print_exc()
                      return False

              def create_minimal_report(self):
                  """Create minimal report when no source files found"""
                  return f"""# üîç Claude AI Code Audit Report

          **Project:** Repository Analysis
          **Audit Date:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
          **Audit Scope:** {self.audit_scope.title()}
          **Status:** No source files detected for analysis

          ## üìä Executive Summary

          No source code files were detected in this repository for analysis. This could indicate:
          - Empty or documentation-only repository
          - Non-standard project structure
          - Files excluded by analysis patterns

          ## üîç Repository Structure

          The repository appears to contain primarily:
          - Documentation files (.md)
          - Configuration files (.json, .yml, .yaml)
          - Other non-source assets

          ## üí° Recommendations

          1. **üìÅ Verify Repository Contents:** Ensure source code files are present
          2. **üîß Update Analysis Patterns:** May need to include additional file types
          3. **üìù Add Documentation:** Consider adding README with project information

          ---
          *Report generated by Claude AI Code Auditor ü§ñ*
          """

          if __name__ == "__main__":
              auditor = RobustClaudeCodeAuditor()
              success = auditor.run_audit()
              sys.exit(0 if success else 1)
          EOF

          echo "üöÄ Starting Claude AI Code Audit..."
          python3 claude_auditor.py
          import random
          from datetime import datetime
          from botocore.config import Config
          from github import Github
          import re

          class ClaudeCodeAuditor:
              def __init__(self):
                  self.github_token = os.environ['GITHUB_TOKEN']
                  self.bedrock_client = self.get_bedrock_client()
                  self.model_id = os.environ.get('AWS_BEDROCK_MODEL_ID', 'us.anthropic.claude-3-5-sonnet-20241022-v2:0')
                  self.audit_scope = os.environ.get('AUDIT_SCOPE', 'all')
                  self.include_suggestions = os.environ.get('INCLUDE_SUGGESTIONS', 'true').lower() == 'true'
                  self.repo_owner = os.environ['REPO_OWNER']
                  self.repo_name = os.environ['REPO_NAME']
                  self.branch_name = "claude-code-audit"
                  
              def get_bedrock_client(self):
                  config = Config(
                      read_timeout=300,
                      connect_timeout=10,
                      retries={
                          'max_attempts': 5,
                          'mode': 'adaptive'
                      }
                  )
                  return boto3.client('bedrock-runtime', region_name=os.environ['AWS_DEFAULT_REGION'], config=config)

              def read_file_safely(self, filepath, max_lines=200):
                  """Read file content safely, limiting lines for context"""
                  try:
                      with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                          lines = f.readlines()
                          if len(lines) > max_lines:
                              return ''.join(lines[:max_lines]) + f'\n... (truncated, {len(lines)-max_lines} more lines)'
                          return ''.join(lines)
                  except Exception as e:
                      return f"Error reading file: {str(e)}"

              def analyze_codebase_structure(self):
                  """Analyze the current codebase for audit context"""
                  print("üìä Analyzing codebase structure...")
                  
                  context = {
                      'project_structure': '',
                      'key_files': {},
                      'source_files': [],
                      'dependencies': '',
                      'file_stats': {}
                  }
                  
                  # Read project structure
                  if os.path.exists('project_structure.txt'):
                      context['project_structure'] = self.read_file_safely('project_structure.txt', 100)
                  
                  # Read dependencies analysis
                  if os.path.exists('dependencies_analysis.txt'):
                      context['dependencies'] = self.read_file_safely('dependencies_analysis.txt', 50)
                  
                  # Read key configuration files
                  key_files = [
                      'package.json', 'tsconfig.json', 'vite.config.ts', 
                      'capacitor.config.ts', 'ionic.config.json', '.eslintrc.json',
                      '.eslintrc.js', 'webpack.config.js'
                  ]
                  
                  for file in key_files:
                      if os.path.exists(file):
                          context['key_files'][file] = self.read_file_safely(file, 100)
                  
                  # Read source files list
                  if os.path.exists('codebase_files.txt'):
                      with open('codebase_files.txt', 'r') as f:
                          context['source_files'] = [line.strip() for line in f.readlines() if line.strip()]
                  
                  # Calculate file statistics
                  total_files = len(context['source_files'])
                  ts_files = len([f for f in context['source_files'] if f.endswith(('.ts', '.tsx'))])
                  js_files = len([f for f in context['source_files'] if f.endswith(('.js', '.jsx'))])
                  css_files = len([f for f in context['source_files'] if f.endswith(('.css', '.scss'))])
                  
                  context['file_stats'] = {
                      'total': total_files,
                      'typescript': ts_files,
                      'javascript': js_files,
                      'css': css_files
                  }
                  
                  return context

              def sample_source_files(self, source_files, max_files=25):
                  """Sample source files for analysis"""
                  print(f"üìÇ Sampling up to {max_files} source files for detailed analysis...")
                  
                  # Prioritize important files
                  priority_patterns = [
                      r'src/.*\.tsx?$',  # React components
                      r'src/.*\.jsx?$',  # JS components
                      r'src/.*service.*\.ts$',  # Services
                      r'src/.*util.*\.ts$',  # Utilities
                      r'src/.*hook.*\.ts$',  # Hooks
                      r'src/.*context.*\.tsx?$',  # Contexts
                      r'src/.*\.css$',  # Styles
                  ]
                  
                  prioritized_files = []
                  remaining_files = []
                  
                  for file in source_files:
                      matched = False
                      for pattern in priority_patterns:
                          if re.search(pattern, file, re.IGNORECASE):
                              prioritized_files.append(file)
                              matched = True
                              break
                      if not matched:
                          remaining_files.append(file)
                  
                  # Select files to analyze
                  selected_files = prioritized_files[:max_files//2] + remaining_files[:max_files//2]
                  selected_files = selected_files[:max_files]
                  
                  file_contents = {}
                  for file_path in selected_files:
                      if os.path.exists(file_path):
                          content = self.read_file_safely(file_path, 150)
                          file_contents[file_path] = content
                          
                  print(f"‚úÖ Successfully sampled {len(file_contents)} files")
                  return file_contents

              def perform_audit_with_claude(self, codebase_context, sampled_files):
                  """Perform comprehensive code audit using Claude"""
                  
                  scope_descriptions = {
                      'all': 'Complete codebase audit covering security, maintainability, performance, and cleanup',
                      'security': 'Security-focused audit for vulnerabilities and unsafe patterns',
                      'performance': 'Performance audit for optimization opportunities',
                      'maintainability': 'Maintainability audit for code quality and structure',
                      'cleanup': 'Cleanup audit for dead code and unused dependencies'
                  }
                  
                  audit_prompt = f"""
          You are an expert code auditor specializing in TypeScript, React, Ionic, and modern web applications. 
          You are performing a {scope_descriptions.get(self.audit_scope, 'comprehensive')} audit of a government billing/invoicing application.

          ## AUDIT SCOPE: {self.audit_scope.upper()}

          ## PROJECT OVERVIEW
          **File Statistics:**
          - Total files: {codebase_context['file_stats']['total']}
          - TypeScript files: {codebase_context['file_stats']['typescript']}
          - JavaScript files: {codebase_context['file_stats']['javascript']}
          - CSS files: {codebase_context['file_stats']['css']}

          **Project Structure:**
          ```
          {codebase_context['project_structure']}
          ```

          **Dependencies:**
          ```
          {codebase_context['dependencies']}
          ```

          ## CONFIGURATION FILES
          """
                  
                  for file, content in codebase_context['key_files'].items():
                      audit_prompt += f"\n**{file}:**\n```\n{content}\n```\n"
                  
                  audit_prompt += "\n## SOURCE CODE SAMPLES\n"
                  
                  for file_path, content in sampled_files.items():
                      audit_prompt += f"\n**{file_path}:**\n```\n{content}\n```\n"
                  
                  # Define audit criteria based on scope
                  if self.audit_scope == 'all' or self.audit_scope == 'security':
                      audit_prompt += """

          ## üîê SECURITY AUDIT CRITERIA
          Please identify and analyze:
          1. **Input Validation Issues:**
             - Unvalidated user inputs
             - Missing sanitization
             - SQL injection risks
             - XSS vulnerabilities

          2. **Authentication & Authorization:**
             - Weak authentication patterns
             - Missing authorization checks
             - Insecure session handling

          3. **Data Protection:**
             - Sensitive data exposure
             - Insecure data storage
             - Missing encryption

          4. **Environment & Configuration:**
             - Hardcoded secrets
             - Insecure configurations
             - Missing environment validation
          """

                  if self.audit_scope == 'all' or self.audit_scope == 'maintainability':
                      audit_prompt += """

          ## üõ†Ô∏è MAINTAINABILITY AUDIT CRITERIA
          Please identify and analyze:
          1. **Code Complexity:**
             - Complex functions/components
             - Deep nesting levels
             - Long parameter lists
             - Unclear logic flows

          2. **Code Quality:**
             - Poor naming conventions
             - Lack of documentation
             - Inconsistent coding styles
             - Missing TypeScript types

          3. **Architecture & Structure:**
             - Circular dependencies
             - Tight coupling
             - Missing abstractions
             - Poor separation of concerns

          4. **Duplication:**
             - Duplicate code blocks
             - Similar logic patterns
             - Redundant components
          """

                  if self.audit_scope == 'all' or self.audit_scope == 'performance':
                      audit_prompt += """

          ## üöÄ PERFORMANCE AUDIT CRITERIA
          Please identify and analyze:
          1. **Rendering Performance:**
             - Unnecessary re-renders
             - Missing React.memo/useMemo
             - Large component trees
             - Inefficient state updates

          2. **Data & API:**
             - Unnecessary API calls
             - Missing caching strategies
             - Large payload sizes
             - Synchronous operations

          3. **Resource Management:**
             - Memory leaks
             - Missing cleanup in useEffect
             - Large bundle sizes
             - Unoptimized images/assets

          4. **Algorithms & Logic:**
             - Inefficient loops
             - Poor data structures
             - Redundant computations
          """

                  if self.audit_scope == 'all' or self.audit_scope == 'cleanup':
                      audit_prompt += """

          ## üßπ CLEANUP AUDIT CRITERIA
          Please identify and analyze:
          1. **Dead Code:**
             - Unused functions/variables
             - Unreachable code
             - Commented-out code blocks
             - Unused imports

          2. **Dependencies:**
             - Unused npm packages
             - Outdated dependencies
             - Security vulnerabilities in deps
             - Duplicate dependencies

          3. **Files & Assets:**
             - Unused files
             - Duplicate assets
             - Old/legacy code
             - Test files in production
          """

                  audit_prompt += f"""

          ## AUDIT INSTRUCTIONS
          Based on your analysis of the provided codebase, create a comprehensive audit report. 

          **Output Format:**

          # üîç Claude AI Code Audit Report

          **Project:** Government Billing/Invoicing Application
          **Audit Date:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
          **Audit Scope:** {self.audit_scope.title()}
          **Files Analyzed:** [Number] files

          ## üìä Executive Summary
          [Brief overview of findings and overall code health]

          ## üîç Detailed Findings

          ### üîê Security Issues
          [Security-related findings - include severity levels: CRITICAL, HIGH, MEDIUM, LOW]

          ### üõ†Ô∏è Maintainability Issues  
          [Code quality and maintainability issues]

          ### üöÄ Performance Issues
          [Performance-related findings]

          ### üßπ Cleanup Opportunities
          [Dead code, unused dependencies, etc.]

          ## üìà Metrics & Statistics
          [Code metrics, complexity scores, etc.]

          ## ‚úÖ Positive Findings
          [Things that are done well]
          """

                  if self.include_suggestions:
                      audit_prompt += """

          ## üí° Improvement Recommendations

          ### Priority 1 (Critical/High)
          [Most important improvements]

          ### Priority 2 (Medium)
          [Important but not urgent improvements]

          ### Priority 3 (Low)
          [Nice-to-have improvements]

          ## üõ†Ô∏è Implementation Guidance
          [Specific steps to address the issues]
          """

                  audit_prompt += """

          ## üìã Action Items Checklist
          [Actionable checklist for developers]

          ---
          *Report generated by Claude AI Code Auditor*

          Please provide specific examples from the code when highlighting issues. Include file names, line numbers (when possible), and code snippets to support your findings.
          Be thorough but concise. Focus on actionable insights that will genuinely improve the codebase.
          """

                  return self.generate_with_retry(audit_prompt)

              def generate_with_retry(self, prompt, max_retries=10):
                  """Generate audit report with retry logic"""
                  print("ü§ñ Sending audit request to Claude AI...")
                  print(f"üìù Prompt length: {len(prompt):,} characters")
                  print(f"üéØ Using model: {self.model_id}")
                  print("=" * 80)
                  
                  for attempt in range(max_retries):
                      try:
                          print(f"üöÄ Attempt {attempt + 1}/{max_retries}")
                          
                          body = {
                              "anthropic_version": "bedrock-2023-05-31",
                              "max_tokens": 15000,
                              "messages": [
                                  {
                                      "role": "user",
                                      "content": prompt
                                  }
                              ]
                          }
                          
                          start_time = time.time()
                          response = self.bedrock_client.invoke_model(
                              body=json.dumps(body),
                              modelId=self.model_id,
                              accept='application/json',
                              contentType='application/json'
                          )
                          
                          response_body = json.loads(response.get('body').read())
                          audit_report = response_body['content'][0]['text']
                          
                          end_time = time.time()
                          generation_time = end_time - start_time
                          
                          print(f"‚úÖ Audit completed in {generation_time:.2f} seconds!")
                          print(f"üìä Report length: {len(audit_report):,} characters")
                          print("=" * 80)
                          
                          return audit_report
                          
                      except Exception as e:
                          error_str = str(e)
                          print(f"‚ùå Attempt {attempt + 1} failed: {error_str}")
                          
                          if attempt < max_retries - 1:
                              delay = min(2 ** attempt + random.uniform(0, 1), 60)
                              print(f"‚è≥ Waiting {delay:.2f} seconds before retry...")
                              time.sleep(delay)
                          else:
                              print("‚ùå All retry attempts exhausted")
                              return None
                  
                  return None

              def save_audit_report(self, audit_report):
                  """Save audit report to file"""
                  print("üíæ Saving audit report...")
                  
                  # Create .github/claude directory if it doesn't exist
                  os.makedirs('.github/claude', exist_ok=True)
                  
                  # Save the audit report
                  audit_file_path = '.github/claude/audit.md'
                  with open(audit_file_path, 'w', encoding='utf-8') as f:
                      f.write(audit_report)
                  
                  print(f"‚úÖ Audit report saved to {audit_file_path}")
                  return audit_file_path

              def create_branch_and_commit(self, audit_file_path):
                  """Create branch and commit audit report"""
                  try:
                      print(f"üåø Creating branch: {self.branch_name}")
                      
                      # Configure git
                      subprocess.run(['git', 'config', 'user.name', 'Claude Auditor'], check=True)
                      subprocess.run(['git', 'config', 'user.email', 'claude-auditor@github-actions.bot'], check=True)
                      
                      # Create and checkout new branch
                      subprocess.run(['git', 'checkout', '-b', self.branch_name], check=True)
                      
                      # Add the audit report
                      subprocess.run(['git', 'add', audit_file_path], check=True)
                      
                      # Create commit message
                      commit_msg = f"""üîç Claude AI Code Audit Report

          Comprehensive codebase audit performed by Claude AI

          Audit Scope: {self.audit_scope}
          Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
          Report: {audit_file_path}

          This automated audit covers:
          üîê Security vulnerabilities and best practices
          üõ†Ô∏è Maintainability and code quality
          üöÄ Performance optimization opportunities  
          üßπ Dead code and cleanup recommendations
          """
                      
                      # Commit changes
                      subprocess.run(['git', 'commit', '-m', commit_msg], check=True)
                      
                      # Push branch
                      subprocess.run(['git', 'push', '-u', 'origin', self.branch_name], check=True)
                      
                      print(f"‚úÖ Successfully pushed audit report to branch: {self.branch_name}")
                      return True
                      
                  except subprocess.CalledProcessError as e:
                      print(f"‚ùå Git operation failed: {e}")
                      return False

              def create_pull_request(self, audit_file_path):
                  """Create pull request for audit report"""
                  try:
                      print("üìù Creating pull request...")
                      
                      github_client = Github(self.github_token)
                      repo = github_client.get_repo(f"{self.repo_owner}/{self.repo_name}")
                      
                      pr_title = f"üîç Claude AI Code Audit Report - {datetime.now().strftime('%Y-%m-%d')}"
                      
                      pr_body = f"""# üîç Claude AI Code Audit Report

          This pull request contains a comprehensive code audit report generated by Claude AI.

          ## üìã Audit Details
          - **Scope:** {self.audit_scope.title()}
          - **Date:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
          - **Report Location:** `{audit_file_path}`
          - **Suggestions Included:** {'Yes' if self.include_suggestions else 'No'}

          ## üéØ Audit Coverage

          {'üîê **Security Analysis** - Vulnerability detection and security best practices' if self.audit_scope in ['all', 'security'] else ''}
          {'üõ†Ô∏è **Maintainability Review** - Code quality and structural improvements' if self.audit_scope in ['all', 'maintainability'] else ''}
          {'üöÄ **Performance Optimization** - Performance bottlenecks and optimization opportunities' if self.audit_scope in ['all', 'performance'] else ''}
          {'üßπ **Code Cleanup** - Dead code, unused dependencies, and cleanup recommendations' if self.audit_scope in ['all', 'cleanup'] else ''}

          ## üìñ How to Use This Report

          1. **Review the findings** in the audit report
          2. **Prioritize issues** based on severity levels
          3. **Create issues** for specific problems that need fixing
          4. **Implement suggestions** to improve code quality
          5. **Schedule regular audits** to maintain code health

          ## ‚ö†Ô∏è Important Notes

          - This audit was performed by AI and should be reviewed by human developers
          - Some findings may be false positives - use your judgment
          - Consider the context of your application when implementing suggestions
          - Not all issues need immediate fixing - focus on high-priority items first

          ## üîÑ Next Steps

          1. Review the complete audit report
          2. Discuss findings with your development team
          3. Create actionable tickets for priority issues
          4. Plan implementation of recommended improvements

          ---
          *Generated automatically by Claude AI Code Auditor ü§ñ*
          """
                      
                      # Try to create PR using GitHub CLI as fallback
                      try:
                          pull_request = repo.create_pull(
                              title=pr_title,
                              body=pr_body,
                              head=self.branch_name,
                              base='main'
                          )
                          
                          # Add labels
                          try:
                              pull_request.add_to_labels('claude-audit', 'code-quality', 'automated')
                          except:
                              pass  # Labels might not exist
                          
                          print(f"‚úÖ Pull request created: {pull_request.html_url}")
                          return pull_request.html_url
                      except Exception as pr_error:
                          if "not permitted" in str(pr_error) or "403" in str(pr_error):
                              print("‚ö†Ô∏è GitHub Actions cannot create PRs directly. Using GitHub CLI fallback...")
                              
                              # Try using GitHub CLI
                              try:
                                  result = subprocess.run([
                                      'gh', 'pr', 'create',
                                      '--title', pr_title,
                                      '--body', pr_body,
                                      '--head', self.branch_name,
                                      '--base', 'main'
                                  ], capture_output=True, text=True, check=True)
                                  
                                  pr_url = result.stdout.strip()
                                  print(f"‚úÖ Pull request created via GitHub CLI: {pr_url}")
                                  return pr_url
                              except subprocess.CalledProcessError as cli_error:
                                  print(f"‚ùå GitHub CLI also failed: {cli_error}")
                                  
                                  # Final fallback - create a summary file instead
                                  print("üìù Creating audit summary instead of PR...")
                                  summary_path = self.create_audit_summary(audit_file_path)
                                  print(f"‚úÖ Audit summary created: {summary_path}")
                                  print("üí° You can manually create a PR from the claude-code-audit branch")
                                  return f"Branch: {self.branch_name} (manual PR needed)"
                          else:
                              raise pr_error
                      
                  except Exception as e:
                      print(f"‚ùå Failed to create pull request: {e}")
                      # Create summary as fallback
                      summary_path = self.create_audit_summary(audit_file_path)
                      print(f"‚úÖ Audit summary created instead: {summary_path}")
                      return None

              def create_audit_summary(self, audit_file_path):
                  """Create a summary file when PR creation fails"""
                  summary_content = f"""# üîç Claude AI Code Audit Summary

          **Audit Completed:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
          **Branch:** {self.branch_name}
          **Report Location:** {audit_file_path}
          **Scope:** {self.audit_scope.title()}

          ## üìã Next Steps

          1. **View the audit report:** `{audit_file_path}`
          2. **Create a Pull Request manually:**
             - Go to your repository on GitHub
             - Switch to the `{self.branch_name}` branch
             - Click "Create Pull Request"
          3. **Review the findings** and implement improvements

          ## üîó Quick Links

          - **Branch:** [{self.branch_name}](https://github.com/{self.repo_owner}/{self.repo_name}/tree/{self.branch_name})
          - **Report:** [{audit_file_path}](https://github.com/{self.repo_owner}/{self.repo_name}/blob/{self.branch_name}/{audit_file_path})

          ---
          *Generated by Claude AI Code Auditor*
          """
                  
                  summary_path = 'AUDIT_SUMMARY.md'
                  with open(summary_path, 'w', encoding='utf-8') as f:
                      f.write(summary_content)
                  
                  # Add and commit the summary
                  try:
                      subprocess.run(['git', 'add', summary_path], check=True)
                      subprocess.run(['git', 'commit', '-m', 'Add audit summary'], check=True)
                      subprocess.run(['git', 'push'], check=True)
                  except:
                      pass
                  
                  return summary_path

              def run_audit(self):
                  """Main audit execution method"""
                  print("üîç Starting Claude AI Code Audit...")
                  print(f"üìã Audit scope: {self.audit_scope}")
                  print(f"üí° Include suggestions: {self.include_suggestions}")
                  print("=" * 80)
                  
                  # Step 1: Analyze codebase structure
                  codebase_context = self.analyze_codebase_structure()
                  
                  # Step 2: Sample source files for detailed analysis
                  sampled_files = self.sample_source_files(codebase_context['source_files'])
                  
                  # Step 3: Perform audit with Claude
                  audit_report = self.perform_audit_with_claude(codebase_context, sampled_files)
                  
                  if not audit_report:
                      print("‚ùå Failed to generate audit report")
                      return False
                  
                  # Step 4: Save audit report
                  audit_file_path = self.save_audit_report(audit_report)
                  
                  # Step 5: Create branch and commit
                  if self.create_branch_and_commit(audit_file_path):
                      # Step 6: Create pull request
                      pr_url = self.create_pull_request(audit_file_path)
                      
                      if pr_url:
                          print("=" * 80)
                          print("üéâ Code audit completed successfully!")
                          print(f"üìÑ Report: {audit_file_path}")
                          print(f"üîó Pull Request: {pr_url}")
                          print("=" * 80)
                          return True
                      else:
                          print("=" * 80)
                          print("üéâ Code audit completed successfully!")
                          print(f"üìÑ Report: {audit_file_path}")
                          print(f"üåø Branch: {self.branch_name}")
                          print("üí° Create a pull request manually from the GitHub interface")
                          print("=" * 80)
                          return True  # Still consider this successful
                  else:
                      print("‚ùå Failed to create branch and commit audit report")
                      return False

          if __name__ == "__main__":
              auditor = ClaudeCodeAuditor()
              success = auditor.run_audit()
              exit(0 if success else 1)
          EOF

          echo "üöÄ Starting Claude AI Code Audit..."
          python3 claude_auditor.py

      - name: Cleanup on failure
        if: failure()
        continue-on-error: true
        run: |
          echo "üßπ Cleaning up after failure..."

          # Clean up any created branch on failure
          AUDIT_BRANCH="${{ steps.repo-info.outputs.audit_branch }}"
          if [[ -n "$AUDIT_BRANCH" ]]; then
            git push origin --delete "$AUDIT_BRANCH" 2>/dev/null || echo "No branch to clean up"
          fi

      - name: Enhanced Summary
        if: always()
        run: |
          echo "üìã Robust Claude AI Code Audit Workflow - Summary"
          echo "================================================="
          echo ""
          echo "üîß Configuration:"
          echo "  üìã Audit Scope: ${{ env.AUDIT_SCOPE }}"
          echo "  üí° Include Suggestions: ${{ env.INCLUDE_SUGGESTIONS }}"
          echo "  üèóÔ∏è Repository Type: ${{ steps.repo-info.outputs.is_fork == 'true' && 'Fork' || 'Original' }}"
          echo "  üéØ Target Repo: ${{ steps.repo-info.outputs.target_repo_owner }}/${{ steps.repo-info.outputs.target_repo_name }}"
          echo "  üåø Target Branch: ${{ steps.repo-info.outputs.target_branch }}"
          echo "  üîç Audit Branch: ${{ steps.repo-info.outputs.audit_branch }}"
          echo ""
          echo "üîç Analysis Coverage:"
          echo "  üîê Security vulnerabilities and best practices"
          echo "  üõ†Ô∏è Code quality and maintainability issues"
          echo "  üöÄ Performance optimization opportunities"
          echo "  üßπ Dead code and cleanup recommendations"
          echo ""
          echo "‚ö° Enhanced Features:"
          echo "  üîÑ Automatic scheduling every 6 hours"
          echo "  üç¥ Smart fork detection and upstream PR creation"
          echo "  üí™ Robust error handling and retry mechanisms"
          echo "  üßπ Automatic cleanup of old audit branches"
          echo "  üìä Comprehensive file analysis and prioritization"
          echo "  üéØ Intelligent target branch detection"
          echo ""
          echo "üìñ Check the pull request for detailed findings and actionable recommendations!"
          echo "üîó Reports are saved in .github/claude-audits/ directory"
          echo ""

          # Show job status
          if [[ "${{ job.status }}" == "success" ]]; then
            echo "‚úÖ Workflow completed successfully!"
          else
            echo "‚ö†Ô∏è Workflow completed with issues. Check logs above for details."
          fi
